<template>
  <div class="community-container">
    <!-- È°∂ÈÉ®ÂØºËà™ÂíåÁ≠õÈÄâÂå∫ -->
    <div class="community-header">
      <div class="filter-tabs">
        <el-tabs v-model="activeTab" class="modern-tabs">
          <el-tab-pane label="üî• ÁÉ≠Èó®" name="hot"></el-tab-pane>
          <el-tab-pane label="‚ö° ÊúÄÊñ∞" name="latest"></el-tab-pane>
          <el-tab-pane label="üëç ÁÇπËµûÊúÄÂ§ö" name="mostLiked"></el-tab-pane>
        </el-tabs>
      </div>
    </div>

    <!-- ÁÉ≠Èó®Ê†áÁ≠æÂå∫ -->
    <div class="hot-tags">
      <div class="tag-section">
        <span class="tag-title">üè∑Ô∏è ÁÉ≠Èó®ËØùÈ¢ò</span>
        <div class="tags-container">
          <el-tag
              type=""
              effect="plain"
              class="tag-item modern-tag"
              @click="filterByTag('')"
              :class="{ 'active-tag': selectedTag === '' }"
          >
            ÂÖ®ÈÉ®
          </el-tag>
          <el-tag
              v-for="tag in hotTags"
              :key="tag.id"
              :type="tag.type"
              effect="plain"
              class="tag-item modern-tag"
              @click="filterByTag(tag.name)"
              :class="{ 'active-tag': selectedTag === tag.name }"
          >
            #{{ tag.name }}
          </el-tag>
        </div>
      </div>
    </div>

    <!-- ÂÜÖÂÆπÂå∫Âüü -->
    <div class="community-content">
      <!-- Â∏ñÂ≠êÂàóË°® -->
      <div class="posts-container">
        <div v-if="loading" class="loading-container">
          <div class="loading-skeleton">
            <el-skeleton :rows="5" animated />
          </div>
        </div>

        <div v-else-if="error" class="error-container">
          <div class="error-card">
            <div class="error-icon">‚ö†Ô∏è</div>
            <div class="error-message">{{ error }}</div>
            <el-button type="primary" @click="fetchAndProcessPosts">ÈáçÊñ∞Âä†ËΩΩ</el-button>
          </div>
        </div>

        <template v-else>
          <div v-for="post in filteredPosts" :key="post.id" class="post-card modern-card">
            <!-- Â∏ñÂ≠êÂ§¥ÈÉ® -->
            <div class="post-header">
              <div class="user-info">
                <div class="avatar-container">
                  <el-avatar :size="44" :src="post.author.avatar" class="user-avatar">
                    <template #default>
                      <div class="avatar-fallback">üë§</div>
                    </template>
                  </el-avatar>
                  <div class="online-indicator"></div>
                </div>
                <div class="user-details">
                  <div class="username">{{ post.author.name }}</div>
                  <div class="post-time">
                    <svg class="time-icon" viewBox="0 0 16 16" fill="currentColor">
                      <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
                      <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
                    </svg>
                    {{ formatTime(post.createdAt) }}
                  </div>
                </div>
              </div>

              <div class="follow-section" v-if="post.author.id !== currentUser.id">
                <el-button
                    :type="post.author.isFollowed ? 'default' : 'primary'"
                    size="small"
                    class="follow-btn"
                    @click="toggleFollow(post.author)"
                    :loading="post.author.followLoading"
                >
                  <span v-if="!post.author.isFollowed">+ ÂÖ≥Ê≥®</span>
                  <span v-else>‚úì Â∑≤ÂÖ≥Ê≥®</span>
                </el-button>
              </div>
            </div>

            <!-- Â∏ñÂ≠êÊ†áÈ¢ò -->
            <div class="post-title" @click="viewPostDetail(post)">
              {{ post.title }}
            </div>

            <!-- Â∏ñÂ≠êÂÜÖÂÆπ -->
            <div class="post-content" @click="viewPostDetail(post)">
              {{ post.summary }}
            </div>

            <!-- Â∏ñÂ≠êÂõæÁâá -->
            <div v-if="post.images && post.images.length > 0" class="post-images">
              <div
                  v-for="(image, index) in post.images.slice(0, 4)"
                  :key="index"
                  class="image-wrapper"
                  :class="`image-${post.images.length > 1 ? 'grid' : 'single'}`"
              >
                <el-image
                    :src="image.url"
                    fit="cover"
                    class="post-image"
                    :preview-src-list="post.images.map(img => img.url)"
                    :initial-index="index"
                />
                <div v-if="index === 3 && post.images.length > 4" class="more-images">
                  +{{ post.images.length - 4 }}
                </div>
              </div>
            </div>

            <!-- Ê†áÁ≠æ -->
            <div class="post-tags" v-if="post.tags && post.tags.length > 0">
              <el-tag
                  v-for="tag in post.tags"
                  :key="tag"
                  size="small"
                  effect="plain"
                  class="post-tag"
                  @click.stop="filterByTag(tag)"
              >
                #{{ tag }}
              </el-tag>
            </div>

            <!-- Êìç‰ΩúÊåâÈíÆ -->
            <div class="post-actions">
              <div class="actions-left">
                <div class="action-item like-action" @click="toggleLike(post)" :class="{ 'active': post.isLiked }">
                  <div class="action-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                    </svg>
                  </div>
                  <span class="action-text">{{ post.likes }}</span>
                </div>

                <div class="action-item comment-action" @click="openComments(post)">
                  <div class="action-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                  </div>
                  <span class="action-text">{{ post.comments.length }}</span>
                </div>

                <div class="action-item favorite-action" @click="openFavoritesModal(post)" :class="{ 'active': post.isFavorited }">
                  <div class="action-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                  </div>
                  <span class="action-text">{{ post.favorites }}</span>
                </div>
              </div>

              <div class="actions-right">
                <div class="share-action" @click="sharePost(post)">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>

          <!-- Á©∫Áä∂ÊÄÅ -->
          <div v-if="filteredPosts.length === 0" class="empty-state">
            <div class="empty-card">
              <div class="empty-icon">üìù</div>
              <div class="empty-title">ÊöÇÊó†Â∏ñÂ≠ê</div>
              <div class="empty-subtitle">Âø´Êù•ÂèëÂ∏ÉÁ¨¨‰∏ÄÁØáÂ∏ñÂ≠êÂêßÔºÅ</div>
            </div>
          </div>

          <!-- Âä†ËΩΩÊõ¥Â§ö -->
          <div v-if="hasMorePosts && !loading" class="load-more">
            <el-button class="load-more-btn" @click="loadMorePosts">
              <span>Âä†ËΩΩÊõ¥Â§öÂÜÖÂÆπ</span>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 14l-7 7-7-7"/>
              </svg>
            </el-button>
          </div>
        </template>
      </div>
    </div>

    <!-- ÂçöÂÆ¢È¢ÑËßàÂØπËØùÊ°Ü -->
    <BlogPreviewDialog
        :visible="showPostDetail"
        :post="previewPost"
        title="ÂçöÂÆ¢È¢ÑËßà"
        @close="showPostDetail = false"
    />

    <!-- ËØÑËÆ∫Ê®°ÊÄÅÊ°Ü -->
    <el-dialog
        v-model="showComments"
        title="üí¨ ËØÑËÆ∫‰∫íÂä®"
        width="50%"
        destroy-on-close
        :append-to-body="true"
        :lock-scroll="false"
        class="comments-dialog modern-dialog"
    >
      <!-- Â∏ñÂ≠êÊ†áÈ¢ò -->
      <div class="comment-post-title">{{ commentPost.title }}</div>

      <!-- ËØÑËÆ∫ËæìÂÖ•Ê°Ü -->
      <div class="comment-input-container">
        <!-- ÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ -->
        <div class="comment-input-header">
          <el-avatar :size="36" :src="currentUser.avatar" class="comment-avatar"></el-avatar>
          <span class="comment-username">{{ currentUser.name }}</span>
        </div>

        <!-- ÂõûÂ§çÁõÆÊ†áÊòæÁ§∫ -->
        <div v-if="replyTarget" class="reply-target">
          ÂõûÂ§ç <span class="reply-target-name">@{{ replyTarget.author.name }}</span>:
          <el-button size="mini" type="text" @click="cancelReply">ÂèñÊ∂à</el-button>
        </div>

        <el-input
            v-model="newComment"
            type="textarea"
            :rows="replyTarget ? 2 : 3"
            placeholder="ÂÜô‰∏ã‰Ω†ÁöÑÊÉ≥Ê≥ï..."
            resize="none"
            class="comment-textarea"
        ></el-input>
        <div class="comment-input-actions">
          <el-button type="primary" @click="submitComment" :loading="commentSubmitting" class="submit-comment-btn">
            {{ replyTarget ? 'ÂõûÂ§ç' : 'ÂèëË°®ËØÑËÆ∫' }}
          </el-button>
        </div>
      </div>

      <!-- ËØÑËÆ∫ÂàóË°® -->
      <div class="comment-list-header">
        <span>üí≠ ÂÖ®ÈÉ®ËØÑËÆ∫ ({{ commentPost.comments.length }})</span>
      </div>

      <div class="comment-list">
        <div v-if="commentPost.comments.length === 0" class="empty-comments">
          <div class="empty-comment-icon">üí¨</div>
          <div class="empty-comment-text">ÊöÇÊó†ËØÑËÆ∫ÔºåÂø´Êù•ÂèëË°®Á¨¨‰∏ÄÊù°ËØÑËÆ∫ÂêßÔºÅ</div>
        </div>

        <div v-else class="comments-container">
          <div v-for="comment in commentPost.comments" :key="comment.id" class="comment-item">
            <!-- ËØÑËÆ∫Â§¥ÈÉ® -->
            <div class="comment-item-header">
              <div class="comment-user-info">
                <el-avatar :size="32" :src="comment.author.avatar" class="comment-user-avatar"></el-avatar>
                <div class="comment-user-details">
                  <div class="comment-username">{{ comment.author.name }}</div>
                  <div class="comment-time">{{ formatTime(comment.createdAt) }}</div>
                </div>
              </div>
            </div>

            <!-- ËØÑËÆ∫ÂÜÖÂÆπ -->
            <div class="comment-item-content">
              {{ comment.content }}

              <!-- ÊòæÁ§∫ÂõûÂ§çÁõÆÊ†á -->
              <div v-if="comment.replyTo" class="reply-to-info">
                ÂõûÂ§ç <span class="reply-to-name">@{{ comment.replyTo.author.name }}</span>
              </div>
            </div>

            <!-- ËØÑËÆ∫Êìç‰Ωú -->
            <div class="comment-item-actions">
              <div class="comment-action-item" @click="toggleCommentLike(comment)" :class="{ 'active': comment.isLiked }">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                </svg>
                <span>{{ comment.likes }}</span>
              </div>
              <div class="comment-action-item" @click="setReplyTarget(comment)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
                <span>ÂõûÂ§ç</span>
              </div>
            </div>

            <!-- ÂõûÂ§çÂàóË°® -->
            <div v-if="comment.replies && comment.replies.length > 0" class="replies-container">
              <div v-for="reply in comment.replies" :key="reply.id" class="reply-item">
                <!-- ÂõûÂ§çÂ§¥ÈÉ® -->
                <div class="reply-header">
                  <el-avatar :size="28" :src="reply.author.avatar" class="reply-avatar"></el-avatar>
                  <div class="reply-user">
                    <span class="reply-username">{{ reply.author.name }}</span>
                    <span class="reply-time">{{ formatTime(reply.createdAt) }}</span>
                  </div>
                </div>

                <!-- ÂõûÂ§çÂÜÖÂÆπ -->
                <div class="reply-content">
                  <span v-if="reply.replyTo" class="reply-to">@{{ reply.replyTo.author.name }}</span>
                  {{ reply.content }}
                </div>

                <!-- ÂõûÂ§çÊìç‰Ωú -->
                <div class="reply-actions">
                  <div class="reply-action" @click="toggleReplyLike(reply)" :class="{ 'active': reply.isLiked }">
                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>
                    </svg>
                    <span>{{ reply.likes }}</span>
                  </div>
                  <div class="reply-action" @click="setReplyTarget(reply, comment)">
                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <span>ÂõûÂ§ç</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </el-dialog>

    <!-- Êî∂ËóèÂ§πÈÄâÊã©Ê®°ÊÄÅÊ°Ü -->
    <el-dialog
        v-model="showFavoritesModal"
        title="üíæ Ê∑ªÂä†Âà∞Êî∂ËóèÂ§π"
        width="480px"
        :show-close="true"
        :close-on-click-modal="false"
        :close-on-press-escape="true"
        class="favorites-modal modern-dialog"
    >
      <div class="favorites-content">
        <!-- ÂàõÂª∫Êî∂ËóèÂ§πÈÄâÈ°π -->
        <div class="create-folder-item" @click="showCreateFolderDialog">
          <div class="folder-info">
            <div class="create-icon">‚ûï</div>
            <span class="folder-name">ÂàõÂª∫Êñ∞Êî∂ËóèÂ§π</span>
          </div>
        </div>

        <!-- Êî∂ËóèÂ§πÂàóË°® -->
        <div class="favorites-list">
          <div
              v-for="folder in favoriteFolders"
              :key="folder.id"
              class="folder-item"
              :class="{ 'recently-used': folder.isRecentlyUsed }"
          >
            <div class="folder-info">
              <div class="folder-main">
                <div class="folder-name">{{ folder.name }}</div>
                <div class="folder-meta">
                  <span class="item-count">{{ folder.itemCount }}Êù°ÂÜÖÂÆπ</span>
                  <span class="separator">¬∑</span>
                  <span class="privacy-status">{{ folder.isPrivate ? 'üîí ÁßÅÂØÜ' : 'üåê ÂÖ¨ÂºÄ' }}</span>
                  <el-tag
                      v-if="folder.isRecentlyUsed"
                      type="warning"
                      size="small"
                      effect="plain"
                      class="recent-tag"
                  >
                    ÊúÄËøë‰ΩøÁî®
                  </el-tag>
                </div>
              </div>
            </div>
            <el-button
                type="primary"
                size="small"
                plain
                class="collect-btn"
                @click="addToFolder(folder)"
                :loading="folder.loading"
            >
              Êî∂Ëóè
            </el-button>
          </div>
        </div>
      </div>
    </el-dialog>

    <!-- ÂàõÂª∫Êî∂ËóèÂ§πÂØπËØùÊ°Ü -->
    <el-dialog
        v-model="showCreateDialog"
        title="üìÅ ÂàõÂª∫Êî∂ËóèÂ§π"
        width="400px"
        :show-close="true"
        :close-on-click-modal="false"
        class="create-dialog modern-dialog"
    >
      <el-form :model="newFolder" label-position="top" class="create-form">
        <el-form-item label="Êî∂ËóèÂ§πÂêçÁß∞" required>
          <el-input
              v-model="newFolder.name"
              placeholder="ËØ∑ËæìÂÖ•Êî∂ËóèÂ§πÂêçÁß∞"
              maxlength="20"
              show-word-limit
              class="form-input"
          />
        </el-form-item>
        <el-form-item label="ÈöêÁßÅËÆæÁΩÆ">
          <el-radio-group v-model="newFolder.isPrivate" class="privacy-group">
            <el-radio :label="false" class="privacy-option">
              <div class="privacy-content">
                <span class="privacy-icon">üåê</span>
                <div class="privacy-text">
                  <div class="privacy-title">ÂÖ¨ÂºÄ</div>
                  <div class="privacy-desc">ÊâÄÊúâ‰∫∫ÂèØËßÅ</div>
                </div>
              </div>
            </el-radio>
            <el-radio :label="true" class="privacy-option">
              <div class="privacy-content">
                <span class="privacy-icon">üîí</span>
                <div class="privacy-text">
                  <div class="privacy-title">ÁßÅÂØÜ</div>
                  <div class="privacy-desc">‰ªÖËá™Â∑±ÂèØËßÅ</div>
                </div>
              </div>
            </el-radio>
          </el-radio-group>
        </el-form-item>
        <el-form-item label="ÊèèËø∞ÔºàÂèØÈÄâÔºâ">
          <el-input
              v-model="newFolder.description"
              type="textarea"
              :rows="3"
              placeholder="‰∏∫Ëøô‰∏™Êî∂ËóèÂ§πÊ∑ªÂä†ÊèèËø∞..."
              maxlength="100"
              show-word-limit
              class="form-textarea"
          />
        </el-form-item>
      </el-form>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="showCreateDialog = false" class="cancel-btn">ÂèñÊ∂à</el-button>
          <el-button
              type="primary"
              @click="createFolder"
              :loading="createLoading"
              :disabled="!newFolder.name.trim()"
              class="create-btn"
          >
            ÂàõÂª∫Êî∂ËóèÂ§π
          </el-button>
        </div>
      </template>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, reactive, computed, onMounted, watch, nextTick, onBeforeUnmount } from 'vue';
import {ElMessage, ElMessageBox} from 'element-plus';
import request from '@/utils/request';
import { useStore } from "vuex";
import { fetchUserAvatar } from '@/utils/userHelper';
import * as userHelper from "@/utils/userHelper.js";
import BlogPreviewDialog from '@/components/BlogPreviewDialog.vue'
import * as postHelper from "@/utils/postHelper.js";
import defaultCover from '@/assets/imgs/default-cover.jpg'

const store = useStore();
const userId = computed(() => store.getters.userId)
const searchQuery = computed(() => store.state.searchQuery)

// ÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ
const currentUser = reactive({
  id: userId.value,
  name: '',
  avatar: ''
});

// Áä∂ÊÄÅÂèòÈáè
const loading = ref(false);
const commentSubmitting = ref(false);
const activeTab = ref('hot');
const showPostDetail = ref(false);
const showComments = ref(false);
const currentPost = ref(null);
const commentPost = ref(null);
const newComment = ref('');
const selectedTag = ref('');
const hasMorePosts = ref(true);
const page = ref(1);
const error = ref(null);
const showFavoritesModal = ref(false)
const showCreateDialog = ref(false)
const createLoading = ref(false)
const coverUrl = ref('')
const posts = ref([]);
const hotTags = ref([]);    // ÁÉ≠Èó®Ê†áÁ≠æ
const replyTarget = ref(null); // ÂΩìÂâçÂõûÂ§çÁöÑÁõÆÊ†áÔºàËØÑËÆ∫ÊàñÂõûÂ§çÔºâ
const replyingToComment = ref(null); // ÂΩìÂõûÂ§çÂõûÂ§çÊó∂ÔºåÊâÄÂ±ûÁöÑÁà∂ËØÑËÆ∫

const fetchHotTags = async () => {
  try {
    loading.value = true;
    const res = await request.get('/tags/hot');
    if (res.code === '200') {
      console.log('Hot tags fetched:', res.data);
      hotTags.value = res.data.map(tag => ({
        id: tag.id,
        name: tag.name,
      }));
    }
  } catch (err) {
    error.value = 'Ëé∑ÂèñÁÉ≠Èó®Ê†áÁ≠æÂ§±Ë¥•';
    console.error('Error fetching hot tags:', err);
  } finally {
    loading.value = false;
  }
};

// ËÆ°ÁÆóÂ±ûÊÄß - Ê†πÊçÆÁ≠õÈÄâÊù°‰ª∂ËøáÊª§Â∏ñÂ≠ê
const filteredPosts = computed(() => {
  let result = [...posts.value];

  // Â∫îÁî®ÊêúÁ¥¢ËøáÊª§
  if (searchQuery.value) {
    const query = searchQuery.value.toLowerCase()
    result = result.filter(post => {
      return (
          post.title.toLowerCase().includes(query) ||
          post.summary.toLowerCase().includes(query) ||
          (post.tags && post.tags.some(tag => tag.toLowerCase().includes(query))) ||
          post.author.name.toLowerCase().includes(query)
      )
    })
  }

  // Ê†πÊçÆÊ†áÁ≠æÁ≠õÈÄâ
  if (selectedTag.value) {
    result = result.filter(post => post.tags.includes(selectedTag.value));
  }

  // Ê†πÊçÆÈÄâÈ°πÂç°ÊéíÂ∫è
  if (activeTab.value === 'hot') {
    // ÁÉ≠Èó®ÊéíÂ∫èÈÄªËæëÔºàÂèØ‰øùÁïôÂéüÊúâÁÆóÊ≥ïÔºâ
    result.sort((a, b) => (b.likes + b.comments.length * 2) - (a.likes + a.comments.length * 2));
  } else if (activeTab.value === 'latest') {
    // ÊåâÊó∂Èó¥ÂÄíÂ∫èÔºàÊúÄÊñ∞Âú®ÂâçÔºâ
    result.sort((a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  } else if (activeTab.value === 'mostLiked') {
    // ÊåâÁÇπËµûÊï∞ÂÄíÂ∫è
    result.sort((a, b) => b.likes - a.likes);
  }

  return result;
});

const previewPost = computed(() => {
  if (!currentPost.value) return {}

  return {
    id: currentPost.value.id,
    title: currentPost.value.title,
    author: currentPost.value.author,
    createdAt: currentPost.value.createdAt,
    category: currentPost.value.tags?.length > 0 ? currentPost.value.tags[0] : '',
    tags: currentPost.value.tags,
    coverUrl: currentPost.value.coverUrl || defaultCover,
    summary: currentPost.value.content ? currentPost.value.content.slice(0, 100) + '...' : '',
    formattedContent: currentPost.value.formattedContent
  }
})

// ÁîüÂëΩÂë®ÊúüÈí©Â≠ê
onMounted(async () => {
  if (currentUser.id) {
    userHelper.fetchCurrentUserDetails(currentUser);
    // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ËØ¶ÁªÜ‰ø°ÊÅØ (name, avatar)
    userHelper.fetchCurrentUserDetails(currentUser)
  }
  fetchHotTags();
  fetchAndProcessPosts();
});

// ÁªÑ‰ª∂Âç∏ËΩΩÊó∂ÁßªÈô§ÁõëÂê¨
onBeforeUnmount(() => {
  window.removeEventListener('beforeunload', () => {
    store.commit('setSearchQuery', '')
  })
})

// Êñ∞Â¢ûÔºöÁõëÂê¨ userId ÁöÑÂèòÂåñÔºå‰ª•Êõ¥Êñ∞ currentUser ‰ø°ÊÅØ
watch(userId, async (newUserId, oldUserId) => {
  currentUser.id = newUserId;
  if (newUserId) {
    await fetchCurrentUserDetails();
  } else {
    currentUser.name = 'ËÆøÂÆ¢';
    currentUser.avatar = '/placeholder.svg?height=40&width=40';
  }
}, { immediate: false });

// ÊñπÊ≥ï - Âä†ËΩΩÊõ¥Â§öÂ∏ñÂ≠ê
const loadMorePosts = () => {
  loading.value = true;
  page.value++;

  // Ê®°ÊãüAPIËØ∑Ê±ÇÂª∂Ëøü
  setTimeout(() => {
    // Ê®°ÊãüÊ≤°ÊúâÊõ¥Â§öÊï∞ÊçÆ
    if (page.value >= 3) {
      hasMorePosts.value = false;
    }
    loading.value = false;
  }, 1000);
};

// ÊñπÊ≥ï - Êü•ÁúãÂ∏ñÂ≠êËØ¶ÊÉÖ
const viewPostDetail = (post) => {
  currentPost.value = JSON.parse(JSON.stringify(post));
  showPostDetail.value = true;
};

// ÊñπÊ≥ï - ÊâìÂºÄËØÑËÆ∫
const openComments = (post) => {
  console.log('openComments called with post:', JSON.parse(JSON.stringify(post))); // Log the post data
  // ‰ΩøÁî®ÂçïÁã¨ÁöÑÂèòÈáèÂ≠òÂÇ®ËØÑËÆ∫Â∏ñÂ≠êÔºåÈÅøÂÖç‰∏éÂ∏ñÂ≠êËØ¶ÊÉÖÂÜ≤Á™Å
  commentPost.value = JSON.parse(JSON.stringify(post));
  console.log('commentPost.value after assignment:', commentPost.value); // Log the assigned commentPost
  showComments.value = true;
  console.log('showComments.value after setting to true:', showComments.value); // Log the state of showComments
};

// ÊñπÊ≥ï - ÁÇπËµûÂ∏ñÂ≠ê
const toggleLike = async (post) => {
  const originalIsLiked = post.isLiked;
  const originalLikes = post.likes;

  post.isLiked = !post.isLiked;
  post.likes += post.isLiked ? 1 : -1;

  try {
    // Ê†πÊçÆÁä∂ÊÄÅÈÄâÊã©ËØ∑Ê±ÇÊñπÊ≥ï
    const response = originalIsLiked
        ? await request.delete('/likes', {
          params: {
            userId: currentUser.id,
            postId: post.id
          }
        })
        : await request.post('/likes', null, {
          params: {
            userId: currentUser.id,
            postId: post.id
          }
        });

    if (response.code === '200') {
      if (originalIsLiked) {
        ElMessage.success('ÂèñÊ∂àÁÇπËµûÊàêÂäü');
      } else {
        ElMessage.success('ÁÇπËµûÊàêÂäü');
      }
    } else {
      post.isLiked = originalIsLiked;
      post.likes = originalLikes;
      ElMessage.error(response.msg || 'Êìç‰ΩúÂ§±Ë¥•');
    }
  } catch (error) {
    post.isLiked = originalIsLiked;
    post.likes = originalLikes;
    ElMessage.error('ËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú');
    console.error('APIËØ∑Ê±ÇÂºÇÂ∏∏:', error);
  }
};

// ÊñπÊ≥ï - ÁÇπËµûËØÑËÆ∫
const toggleCommentLike = async (comment) => {
  try {
    // ‰øùÂ≠òÂéüÂßãÁä∂ÊÄÅÁî®‰∫éÈîôËØØÂõûÊªö
    const originalIsLiked = comment.isLiked
    const originalLikes = comment.likes
    
    // Á´ãÂç≥Êõ¥Êñ∞UIÁä∂ÊÄÅ
    comment.isLiked = !comment.isLiked
    comment.likes += comment.isLiked ? 1 : -1

    // Ë∞ÉÁî®ÂêéÁ´ØÊé•Âè£
    const response = comment.isLiked 
      ? await request.post('/comments/likes', null, {
          params: {
            commentId: comment.id,
            userId: currentUser.id
          }
        })
      : await request.delete('/comments/likes', {
          params: {
            commentId: comment.id,
            userId: currentUser.id
          }
        })

    if (response.code !== '200') {
      // ÂõûÊªöÁä∂ÊÄÅ
      comment.isLiked = originalIsLiked
      comment.likes = originalLikes
      ElMessage.error(response.message || 'Êìç‰ΩúÂ§±Ë¥•')
    } else {
      ElMessage.success(comment.isLiked ? 'ÁÇπËµûÊàêÂäü' : 'ÂèñÊ∂àÁÇπËµûÊàêÂäü')
    }
  } catch (error) {
    // ËØ∑Ê±ÇÂ§±Ë¥•ÂõûÊªöÁä∂ÊÄÅ
    comment.isLiked = originalIsLiked
    comment.likes = originalLikes
    console.error('ÁÇπËµûÊìç‰ΩúÂ§±Ë¥•:', error)
    ElMessage.error('ÁΩëÁªúÂºÇÂ∏∏ÔºåËØ∑Á®çÂêéÈáçËØï')
  }
}

// ËÆæÁΩÆÂõûÂ§çÁõÆÊ†á
const setReplyTarget = (target, parentComment = null) => {
  replyTarget.value = target;
  replyingToComment.value = parentComment;

  // ÊªöÂä®Âà∞ËæìÂÖ•Ê°Ü
  nextTick(() => {
    const textarea = document.querySelector('.comment-textarea textarea');
    if (textarea) {
      textarea.focus();
      textarea.scrollIntoView({ behavior: 'smooth' });
    }
  });
};

// ÂèñÊ∂àÂõûÂ§ç
const cancelReply = () => {
  replyTarget.value = null;
  replyingToComment.value = null;
};

// Êèê‰∫§ËØÑËÆ∫/ÂõûÂ§ç
const submitComment = async () => {
  if (!newComment.value.trim()) {
    ElMessage.warning('ËØ∑ËæìÂÖ•ËØÑËÆ∫ÂÜÖÂÆπ');
    return;
  }

  commentSubmitting.value = true;

  try {
    const isReply = !!replyTarget.value;
    const commentData = {
      postId: commentPost.value.id,
      userId: currentUser.id,
      content: newComment.value.trim(),
      parentId: isReply ? replyTarget.value.id : null,
      replyTo: isReply ? replyTarget.value.userId : null,
      createdAt: new Date().toISOString()
    };

    const res = await request.post('/comment/add', commentData);

    if (res.code === '200') {
      const newCommentObj = {
        ...res.data,
        author: {
          name: currentUser.username,
          avatar: currentUser.avatar
        },
        likes: 0,
        isLiked: false,
        replies: [] // ÂàùÂßãÂåñÂõûÂ§çÊï∞ÁªÑ
      };

      // Â¶ÇÊûúÊòØÂõûÂ§ç
      if (isReply) {
        // Â¶ÇÊûúÊòØÂõûÂ§çËØÑËÆ∫
        if (!replyingToComment.value) {
          // ÊâæÂà∞Ë¢´ÂõûÂ§çÁöÑËØÑËÆ∫
          const targetComment = commentPost.value.comments.find(c => c.id === replyTarget.value.id);
          if (targetComment) {
            // ÂàùÂßãÂåñrepliesÊï∞ÁªÑÂ¶ÇÊûú‰∏çÂ≠òÂú®
            if (!targetComment.replies) targetComment.replies = [];
            targetComment.replies.push(newCommentObj);
          }
        }
        // Â¶ÇÊûúÊòØÂõûÂ§çÂõûÂ§ç
        else {
          // ÊâæÂà∞Áà∂ËØÑËÆ∫
          const parentComment = commentPost.value.comments.find(c => c.id === replyingToComment.value.id);
          if (parentComment) {
            // ÂàùÂßãÂåñrepliesÊï∞ÁªÑÂ¶ÇÊûú‰∏çÂ≠òÂú®
            if (!parentComment.replies) parentComment.replies = [];

            // ÊâæÂà∞Ë¢´ÂõûÂ§çÁöÑÂõûÂ§ç
            const targetReply = parentComment.replies.find(r => r.id === replyTarget.value.id);
            if (targetReply) {
              // ÂàùÂßãÂåñrepliesÊï∞ÁªÑÂ¶ÇÊûú‰∏çÂ≠òÂú®
              if (!targetReply.replies) targetReply.replies = [];
              targetReply.replies.push(newCommentObj);
            } else {
              // Áõ¥Êé•Ê∑ªÂä†Âà∞Áà∂ËØÑËÆ∫ÁöÑÂõûÂ§çÂàóË°®
              parentComment.replies.push(newCommentObj);
            }
          }
        }
      }
      // Â¶ÇÊûúÊòØÈ°∂Á∫ßËØÑËÆ∫
      else {
        commentPost.value.comments.unshift(newCommentObj);
      }

      // ÂêåÊ≠•Âà∞‰∏ªÂ∏ñÂ≠êÂàóË°®
      const originalPost = posts.value.find(p => p.id === commentPost.value.id);
      if (originalPost) {
        // ‰ΩøÁî®Áõ∏ÂêåÁöÑÈÄªËæëÊõ¥Êñ∞ÂéüÂßãÂ∏ñÂ≠ê
        if (isReply) {
          if (!replyingToComment.value) {
            const targetComment = originalPost.comments.find(c => c.id === replyTarget.value.id);
            if (targetComment) {
              if (!targetComment.replies) targetComment.replies = [];
              targetComment.replies.push(newCommentObj);
            }
          } else {
            const parentComment = originalPost.comments.find(c => c.id === replyingToComment.value.id);
            if (parentComment) {
              if (!parentComment.replies) parentComment.replies = [];

              const targetReply = parentComment.replies.find(r => r.id === replyTarget.value.id);
              if (targetReply) {
                if (!targetReply.replies) targetReply.replies = [];
                targetReply.replies.push(newCommentObj);
              } else {
                parentComment.replies.push(newCommentObj);
              }
            }
          }
        } else {
          originalPost.comments.unshift(newCommentObj);
        }
      }

      // ÈáçÁΩÆÁä∂ÊÄÅ
      newComment.value = '';
      cancelReply();
      ElMessage.success(isReply ? 'ÂõûÂ§çÊàêÂäü' : 'ËØÑËÆ∫ÊàêÂäü');
    } else {
      ElMessage.error(`Êìç‰ΩúÂ§±Ë¥•Ôºö${res.msg}`);
    }
  } catch (error) {
    console.error('Êèê‰∫§Â§±Ë¥•:', error);
    ElMessage.error(`ËØ∑Ê±ÇÂºÇÂ∏∏Ôºö${error.message}`);
  } finally {
    commentSubmitting.value = false;
  }
};

const toggleReplyInput = (comment) => {
  // ÂÆûÁé∞ÊòæÁ§∫/ÈöêËóèÂõûÂ§çËæìÂÖ•Ê°ÜÈÄªËæë
  comment.showReply = !comment.showReply;
  // Ëá™Âä®ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
  nextTick(() => {
    if (comment.showReply) {
      document.querySelector(`#reply-input-${comment.id}`)?.focus();
    }
  });
};

// ‰øÆÊîπËé∑ÂèñËØÑËÆ∫ÁöÑÊñπÊ≥ïÔºåÊîØÊåÅÂµåÂ•óÂõûÂ§ç
const fetchComments = async (postId) => {
  try {
    const res = await request.get('/comment/post', {
      params: { postId }
    });

    if (res.code === '200') {
      // ÂàõÂª∫ËØÑËÆ∫Êò†Â∞ÑÂíåÁà∂ËØÑËÆ∫Êï∞ÁªÑ
      const commentMap = new Map();
      const parentComments = [];
      const repliesMap = new Map();

      // È¶ñÂÖàÂ§ÑÁêÜÊâÄÊúâËØÑËÆ∫ÔºåÂª∫Á´ãÊò†Â∞Ñ
      res.data.forEach(comment => {
        commentMap.set(comment.id, comment);
        // ÂàùÂßãÂåñÂõûÂ§çÊï∞ÁªÑ
        comment.replies = [];

        if (comment.parentId === null) {
          parentComments.push(comment);
        }
      });

      // Â∞ÜÂõûÂ§çÂÖ≥ËÅîÂà∞Áà∂ËØÑËÆ∫
      res.data.forEach(comment => {
        if (comment.parentId !== null) {
          const parentComment = commentMap.get(comment.parentId);
          if (parentComment) {
            // ËÆæÁΩÆÂõûÂ§çÁõÆÊ†á‰ΩúËÄÖ‰ø°ÊÅØ
            comment.replyToAuthor = parentComment.author;
            parentComment.replies.push(comment);
          }
        }
      });

      return parentComments;
    }
  } catch (error) {
    console.error('Ëé∑ÂèñËØÑËÆ∫Â§±Ë¥•:', error);
  }
  return [];
};

// ÊñπÊ≥ï - Ê†πÊçÆÊ†áÁ≠æÁ≠õÈÄâ
const filterByTag = (tag) => {
  selectedTag.value = tag;
};

// Êñ∞Â¢ûÂàÜ‰∫´ÊñπÊ≥ï
const sharePost = (post) => {
    if (navigator.share) {
      navigator.share({
        title: post.title,
        text: post.summary,
        url: `${window.location.origin}/blog-detail?postId=${post.id}`
      })
    } else {
      navigator.clipboard.writeText(`${window.location.origin}/blog-detail?postId=${post.id}`)
      ElMessage.success('ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø')
    }
  }

// ÊñπÊ≥ï - Ê†ºÂºèÂåñÊó∂Èó¥
const formatTime = (dateInput) => {
  let date = dateInput;

  // Â¶ÇÊûú dateInput ‰∏çÊòØ Date ÂØπË±°ÂÆû‰æãÔºåÂπ∂‰∏îÊòØÂ≠óÁ¨¶‰∏≤Á±ªÂûãÔºåÂàôÂ∞ùËØïËΩ¨Êç¢
  if (!(dateInput instanceof Date) && typeof dateInput === 'string') {
    date = new Date(dateInput);
  } else if (dateInput instanceof Date) {
    date = dateInput;
  } else {
    // Â¶ÇÊûúËæìÂÖ•Êó¢‰∏çÊòØDateÂÆû‰æã‰πü‰∏çÊòØÊúâÊïàÊó•ÊúüÂ≠óÁ¨¶‰∏≤ÔºåÂàôÊ†áËÆ∞‰∏∫Êó†Êïà
    console.error('Invalid date input to formatTime:', dateInput);
    return 'Êó•ÊúüÊó†Êïà';
  }

  // Á°Æ‰øùËΩ¨Êç¢ÂêéÊàñÂéüÂßãÁöÑdateÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑDateÂØπË±°
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    console.error('formatTime could not parse date:', dateInput);
    return 'Êó•ÊúüËß£ÊûêÂ§±Ë¥•';
  }

  const now = new Date();
  const diff = now.getTime() - date.getTime();

  // Â∞è‰∫é1ÂàÜÈíü
  if (diff < 60000) {
    return 'ÂàöÂàö';
  }

  // Â∞è‰∫é1Â∞èÊó∂
  if (diff < 3600000) {
    return `${Math.floor(diff / 60000)}ÂàÜÈíüÂâç`;
  }

  // Â∞è‰∫é1Â§©
  if (diff < 86400000) {
    return `${Math.floor(diff / 3600000)}Â∞èÊó∂Ââç`;
  }

  // Â∞è‰∫é1Âë®
  if (diff < 604800000) {
    return `${Math.floor(diff / 86400000)}Â§©Ââç`;
  }

  // Ê†ºÂºèÂåñÊó•Êúü
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');

  return `${year}-${month}-${day}`;
};

// ‰ªéÂêéÁ´ØËé∑ÂèñÂíåÂ§ÑÁêÜÂ∏ñÂ≠êÊï∞ÊçÆ
const fetchAndProcessPosts = async () => {
  loading.value = true;
  error.value = null;
  try {
    const res = await request.get('/posts/selectAll');
    if (res.code === '200' && Array.isArray(res.data)) {
      console.log('‰ªéÂêéÁ´ØËé∑ÂèñÁöÑÂ∏ñÂ≠êÊï∞ÊçÆ:', res.data);
      posts.value = await Promise.all(
          res.data.map(async (postData) => {
            let authorName = 'Êú™Áü•Áî®Êà∑';
            let authorAvatar = '/placeholder.svg?height=40&width=40';

            if (postData.userId) {
              try {
                const userRes = await request.post(`/user/getUser`, null, {
                  params: { userId: postData.userId }
                });
                if (userRes.code === '200' && userRes.data) {
                  authorName = userRes.data.username || 'Êú™Áü•Áî®Êà∑';
                }
                authorAvatar = await fetchUserAvatar(postData.userId);

                const likeRes = await request.get(`/likes/count/${postData.id}`)
                if (likeRes.code === '200') {
                  postData.likes = likeRes.data;
                }

                const isLikedRes = await request.get(`/likes/check`, {
                  params: {
                    postId: postData.id,
                    userId: postData.userId,
                  }
                })
                if (isLikedRes.code === '200') {
                  postData.isLiked = isLikedRes.data;
                }

                const isFavoritedRes = await request.get('/favorites/check', {
                  params: {
                    postId: postData.id,
                    userId: userId.value // ÂΩìÂâçÁôªÂΩïÁî®Êà∑ID
                  }
                });
                if (isFavoritedRes.code === '200') {
                  postData.isFavorited = isFavoritedRes.data;
                }

                const favoritesRes = await request.get(`/favorites/count`, {
                  params: {
                    postId: postData.id,
                  }
                });
                if (favoritesRes.code === '200') {
                  postData.favorites = favoritesRes.data;
                }

                const followCheckRes = await request.get('/follow/check', {
                  params: {
                    followerId: currentUser.id,
                    followedId: postData.userId,
                  }
                })
                if (followCheckRes.code === '200') {
                  postData.isFollowed = followCheckRes.data;
                }

                const commentRes = await request.get('/comment/post', {
                  params: {
                    postId: postData.id,
                  }
                })
                if (commentRes.code === '200') {
                  // Âπ∂Ë°åËé∑ÂèñËØÑËÆ∫‰ΩúËÄÖ‰ø°ÊÅØ
                  postData.comments = await Promise.all(
                    commentRes.data.map(async comment => {
                      try {
                        const [userRes, likesRes, isLikedRes] = await Promise.all([
                          request.post(`/user/getUser`, null, {
                            params: { userId: comment.userId }
                          }),
                          request.get(`/comments/likes/count/${comment.id}`),
                          request.get(`/comments/likes/check`, {
                            params: {
                              commentId: comment.id,
                              userId: currentUser.id
                            }
                          })
                        ]);

                        return {
                          ...comment,
                          likes: likesRes.data || 0,
                          isLiked: isLikedRes.data || false,
                          author: {
                            name: userRes.data.username || 'Êú™Áü•Áî®Êà∑',
                            avatar: await fetchUserAvatar(comment.userId)
                          }
                        };
                      } catch (e) {
                        console.error(`Ëé∑ÂèñËØÑËÆ∫${comment.id}Áõ∏ÂÖ≥‰ø°ÊÅØÂ§±Ë¥•:`, e);
                        return {
                          ...comment,
                          likes: 0,
                          isLiked: false,
                          author: {
                            name: 'Êú™Áü•Áî®Êà∑',
                            avatar: '/placeholder.svg?height=32&width=32'
                          }
                        };
                      }
                  })
                );
                }
              } catch (userError) {
                console.error(`Ëé∑ÂèñÁî®Êà∑ ${postData.userId} ‰ø°ÊÅØÂ§±Ë¥•:`, userError);
              }
            }

            // Á°Æ‰øù images Âíå comments Â≠óÊÆµÂ≠òÂú®‰∏î‰∏∫Êï∞ÁªÑ
            const comments = Array.isArray(postData.comments) ? postData.comments.map(comment => ({
              ...comment,
              author: comment.author || { name: 'Êú™Áü•Áî®Êà∑', avatar: '/placeholder.svg?height=32&width=32' }, // Á°Æ‰øùËØÑËÆ∫‰ΩúËÄÖ‰ø°ÊÅØÂ≠òÂú®
              createdAt: comment.createdAt || new Date().toISOString(), // Á°Æ‰øùËØÑËÆ∫Êó∂Èó¥Â≠òÂú®
              likes: comment.likes || 0,
              isLiked: comment.isLiked || false,
            })) : [];
            const tagRes = await request.get('/post-tags/name', {
              params: { postId: postData.id }
            })
            coverUrl.value = await postHelper.fetchCover(postData.userId, postData.id);

            return {
              id: postData.id,
              title: postData.title,
              summary: postData.summary,
              content: postData.content,
              formattedContent: postData.formattedContent,
              views: postData.views || 0,
              author: {
                id: postData.userId,
                name: authorName,
                avatar: authorAvatar,
                isFollowed: postData.isFollowed,
                followLoading: false
              },
              coverUrl: coverUrl.value,
              createdAt: postData.createdAt || new Date().toISOString(), // ÂêéÁ´ØÂ∫îÊèê‰æõÊ†áÂáÜÊó•ÊúüÂ≠óÁ¨¶‰∏≤
              tags: tagRes.data || [],
              likes: postData.likes || 0,
              isLiked: postData.isLiked || false,
              favorites: postData.favorites || 0,
              isFavorited: postData.isFavorited || false,
              comments: comments,
            };
          })
      );
      console.log('Â§ÑÁêÜÂêéÁöÑÂ∏ñÂ≠êÊï∞ÊçÆ:', posts.value); // Ë∞ÉËØïËæìÂá∫
      hasMorePosts.value = false;
    } else if (res.code !== '200') {
      throw new Error(res.msg || 'Ëé∑ÂèñÂ∏ñÂ≠êÂ§±Ë¥•');
    } else {
      posts.value = []; // Â¶ÇÊûú res.data ‰∏çÊòØÊï∞ÁªÑÔºåÂàôËÆæÁΩÆ‰∏∫Á©∫
      hasMorePosts.value = false;
    }
  } catch (err) {
    console.error('Ëé∑ÂèñÁ§æÂå∫Â∏ñÂ≠êÂ§±Ë¥•:', err);
    error.value = `Êó†Ê≥ïÂä†ËΩΩÂ∏ñÂ≠êÔºö${err.message || 'ËØ∑Á®çÂêéÈáçËØï'}`;
    posts.value = []; // Âá∫ÈîôÊó∂Ê∏ÖÁ©∫Â∏ñÂ≠ê
    hasMorePosts.value = false;
  } finally {
    loading.value = false;
  }
};

// ÂÖ≥Ê≥®/ÂèñÊ∂àÂÖ≥Ê≥®Áî®Êà∑
const toggleFollow = async (author) => {
  if (!currentUser.id) {
    ElMessage.warning('ËØ∑ÂÖàÁôªÂΩï');
    return;
  }

  const originalIsFollowed = author.isFollowed;
  author.followLoading = true;

  try {
    const response = originalIsFollowed
        ? await request.delete('/follow/unfollow', {
          params: {
            followerId: currentUser.id,
            followedId: author.id
          }
        })
        : await request.post('/follow/add', null, {
          params: {
            followerId: currentUser.id,
            followedId: author.id
          }
        });

    if (response.code === '200') {
      author.isFollowed = !originalIsFollowed;

      // ÂêåÊ≠•Êõ¥Êñ∞ÊâÄÊúâÁõ∏ÂÖ≥Â∏ñÂ≠êÁöÑÂÖ≥Ê≥®Áä∂ÊÄÅ
      posts.value.forEach(post => {
        if (post.author.id === author.id) {
          post.author.isFollowed = author.isFollowed;
        }
      });

      // ÂêåÊ≠•Êõ¥Êñ∞ÂΩìÂâçÂ∏ñÂ≠êËØ¶ÊÉÖÁöÑÂÖ≥Ê≥®Áä∂ÊÄÅ
      if (currentPost.value && currentPost.value.author.id === author.id) {
        currentPost.value.author.isFollowed = author.isFollowed;
      }

      ElMessage.success(author.isFollowed ? 'ÂÖ≥Ê≥®ÊàêÂäü' : 'ÂèñÊ∂àÂÖ≥Ê≥®ÊàêÂäü');
    } else {
      ElMessage.error(response.msg || 'Êìç‰ΩúÂ§±Ë¥•');
    }
  } catch (error) {
    ElMessage.error('ËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú');
    console.error('ÂÖ≥Ê≥®Êìç‰ΩúÂ§±Ë¥•:', error);
  } finally {
    author.followLoading = false;
  }
};

// Êî∂ËóèÂ§πÊï∞ÊçÆ
const favoriteFolders = ref([])

// Êñ∞Âª∫Êî∂ËóèÂ§πË°®Âçï
const newFolder = reactive({
  name: '',
  isPrivate: false,
  description: ''
})

// Ëé∑ÂèñÊî∂ËóèÂ§πÂàóË°®
const fetchFavoriteFolders = async () => {
  try {
    const res = await request.get('/favorites/collections/list', {
      params: { userId: userId.value }
    })

    if (res.code === '200') {
      // Ëé∑ÂèñÂü∫Á°ÄÊî∂ËóèÂ§πÂàóË°®
      const baseFolders = res.data;
      console.log('Ëé∑ÂèñÂà∞ÁöÑÊî∂ËóèÂ§πÂàóË°®:', baseFolders);

      // Âπ∂Ë°åËØ∑Ê±ÇÊØè‰∏™Êî∂ËóèÂ§πÁöÑÂ∏ñÂ≠êÊï∞Èáè
      const foldersWithCount = await Promise.all(
          baseFolders.map(async item => {
            try {
              const countRes = await request.get(`/favorites/collection/count`, {
                params: {
                  collectionId: item.id,
                }
              });
              const collectionRes = await request.get('/favorites/collections', {
                params: {
                  collectionId: item.id
                }
              })
              console.log("collectionRes:", collectionRes)
              return {
                ...item,
                itemCount: countRes.data || 0,
                isPrivate: !collectionRes.data.public,
                lastUsedTime: collectionRes.data.updatedAt || 0
              };
            } catch (e) {
              console.error(`Ëé∑ÂèñÊî∂ËóèÂ§π${item.id}Êï∞ÈáèÂ§±Ë¥•:`, e);
              return {
                ...item,
                itemCount: 0
              };
            }
          })
      );

      favoriteFolders.value = foldersWithCount.map(item => ({
        id: item.id,
        name: item.name,
        itemCount: item.itemCount,
        isPrivate: item.isPrivate,
        isRecentlyUsed: item.lastUsedTime > Date.now() - 7 * 86400000
      }));

      console.log('Â§ÑÁêÜÂêéÁöÑÊî∂ËóèÂ§πÂàóË°®:', favoriteFolders.value);
    }
  } catch (error) {
    ElMessage.error('Ëé∑ÂèñÊî∂ËóèÂ§πÂàóË°®Â§±Ë¥•');
    console.error('APIËØ∑Ê±ÇÂ§±Ë¥•:', error);
  }
};

// ÊâìÂºÄÊî∂ËóèÂ§πÊ®°ÊÄÅÊ°Ü
const openFavoritesModal = async (post) => {
  currentPost.value = post;

  // ÂÖàÊ£ÄÊü•Êî∂ËóèÁä∂ÊÄÅ
  if (currentPost.value.isFavorited) {
    try {
      await ElMessageBox.confirm(
          'Á°ÆÂÆöË¶ÅÂèñÊ∂àÊî∂ËóèÂêóÔºü',
          'ÊèêÁ§∫',
          { type: 'warning' }
      );

      // ÊâßË°åÂèñÊ∂àÊî∂ËóèÈÄªËæë
      const res = await request.delete('/favorites/remove', {
        params: {
          postId: currentPost.value.id,
          userId: userId.value
        }
      });

      if (res.code === '200') {
        currentPost.value.favorites--;
        currentPost.value.isFavorited = false;
        ElMessage.success('Â∑≤ÂèñÊ∂àÊî∂Ëóè');
      }
    } catch (error) {
      if (error !== 'cancel') {
        ElMessage.error('ÂèñÊ∂àÊî∂ËóèÂ§±Ë¥•Ôºö' + error.message);
      }
    }
    return;
  }

  // Êú™Êî∂ËóèÊó∂Âä†ËΩΩÊî∂ËóèÂ§π
  try {
    await fetchFavoriteFolders();
    showFavoritesModal.value = true;
  } catch (error) {
    ElMessage.error('Êó†Ê≥ïÂä†ËΩΩÊî∂ËóèÂ§πÔºö' + error.message);
  }
}

// ÊòæÁ§∫ÂàõÂª∫Êî∂ËóèÂ§πÂØπËØùÊ°Ü
const showCreateFolderDialog = () => {
  showCreateDialog.value = true
}

// Ê∑ªÂä†Âà∞Êî∂ËóèÂ§π
const addToFolder = async (folder) => {
  if (!currentPost.value) return

  // ÂéüÊù•Ê≤°Êî∂ËóèÔºåÂÜçÊ¨°ÁÇπÂáªÂàôÊî∂Ëóè
  folder.loading = true
  try {
    const res = await request.post('/favorites/add', {
      collectionId: folder.id,
      postId: currentPost.value.id,
      userId: userId.value,
      createdAt: new Date().toISOString()
    });

    if (res.code === '200') {
      // Êõ¥Êñ∞Êú¨Âú∞Êï∞ÊçÆ
      folder.itemCount++
      currentPost.value.favorites++
      currentPost.value.isFavorited = true

      ElMessage.success(`Â∑≤Êî∂ËóèÂà∞"${folder.name}"`);
      showFavoritesModal.value = false;
    } else {
      ElMessage.error('Êî∂ËóèÂ§±Ë¥•Ôºö' + res.msg);
    }
  } catch (error) {
    ElMessage.error('ËØ∑Ê±ÇÂºÇÂ∏∏Ôºö' + error.message);
  } finally {
    folder.loading = false;
  }
}

// ÂàõÂª∫Êî∂ËóèÂ§π
const createFolder = async () => {
  if (!newFolder.name.trim()) {
    ElMessage.warning('ËØ∑ËæìÂÖ•Êî∂ËóèÂ§πÂêçÁß∞')
    return
  }

  createLoading.value = true
  console.log('ÂÖ¨ÂºÄÔºö', typeof(!newFolder.isPrivate))

  try {
    const res = await request.post('/favorites/collection', null, {
      params: {
        name: newFolder.name,
        description: newFolder.description,
        isPublic: !newFolder.isPrivate,
        userId: userId.value
      }
    })

    // Êõ¥Êñ∞Êî∂ËóèÂ§πÂàóË°®
    if (res.code == '200') {
      favoriteFolders.value.unshift({
        id: res.data.id,
        name: res.data.name,
        itemCount: 0,
        isPrivate: !res.data.isPublic,
        isRecentlyUsed: true,
        loading: false
      })
      // ÈáçÁΩÆË°®Âçï
      newFolder.name = ''
      newFolder.isPrivate = false
      newFolder.description = ''

      showCreateDialog.value = false
      ElMessage.success('Êî∂ËóèÂ§πÂàõÂª∫ÊàêÂäü')
    }
  } catch (error) {
    console.error('ÂàõÂª∫Â§±Ë¥•:', error)
    ElMessage.error(error.response?.data?.message || 'ÂàõÂª∫Â§±Ë¥•ÔºåËØ∑ÈáçËØï')
  } finally {
    createLoading.value = false
  }
}
</script>

<style scoped>
/* ÂÖ®Â±ÄÂÆπÂô® */
.community-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  min-height: 100vh;
}

/* Â§¥ÈÉ®Âå∫Âüü */
.community-header {
  background: white;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(10px);
}

.modern-tabs :deep(.el-tabs__header) {
  margin: 0;
  border: none;
}

.modern-tabs :deep(.el-tabs__nav-wrap::after) {
  display: none;
}

.modern-tabs :deep(.el-tabs__item) {
  padding: 12px 24px;
  font-weight: 500;
  border-radius: 12px;
  margin-right: 8px;
  transition: all 0.3s ease;
  border: 2px solid transparent;
}

.modern-tabs :deep(.el-tabs__item.is-active) {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-color: transparent;
}

.modern-tabs :deep(.el-tabs__active-bar) {
  display: none;
}

/* Ê†áÁ≠æÂå∫Âüü */
.hot-tags {
  background: white;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 24px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.tag-section {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.tag-title {
  font-weight: 600;
  font-size: 16px;
  color: #2c3e50;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.modern-tag {
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  border: 2px solid #e9ecef;
  background: #f8f9fa;
  font-weight: 500;
}

.modern-tag:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.active-tag {
  background: linear-gradient(135deg, #ff6b6b, #ee5a24) !important;
  color: white !important;
  border-color: transparent !important;
  box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
}

/* Â∏ñÂ≠êÂÆπÂô® */
.posts-container {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

/* Áé∞‰ª£ÂåñÂ∏ñÂ≠êÂç°Áâá */
.modern-card {
  background: white;
  border-radius: 20px;
  padding: 24px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  border: 1px solid rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.modern-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #667eea, #764ba2);
  opacity: 0;
  transition: opacity 0.3s ease;
}

.modern-card:hover {
  transform: translateY(-8px);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
}

.modern-card:hover::before {
  opacity: 1;
}

/* Â∏ñÂ≠êÂ§¥ÈÉ® */
.post-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.avatar-container {
  position: relative;
}

.user-avatar {
  border: 3px solid #f8f9fa;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.user-avatar:hover {
  transform: scale(1.1);
}

.avatar-fallback {
  font-size: 20px;
}

.online-indicator {
  position: absolute;
  bottom: 2px;
  right: 2px;
  width: 12px;
  height: 12px;
  background: #52c41a;
  border: 2px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.user-details {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.username {
  font-weight: 600;
  font-size: 15px;
  color: #2c3e50;
}

.post-time {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 13px;
  color: #6c757d;
}

.time-icon {
  width: 14px;
  height: 14px;
}

.follow-btn {
  border-radius: 20px;
  padding: 8px 16px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.follow-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Â∏ñÂ≠êÂÜÖÂÆπ */
.post-title {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 16px;
  cursor: pointer;
  color: #2c3e50;
  line-height: 1.4;
  transition: color 0.3s ease;
}

.post-title:hover {
  color: #667eea;
}

.post-content {
  margin-bottom: 20px;
  font-size: 15px;
  line-height: 1.7;
  color: #495057;
  cursor: pointer;
  transition: color 0.3s ease;
}

.post-content:hover {
  color: #2c3e50;
}

/* ÂõæÁâáÁΩëÊ†º */
.post-images {
  display: grid;
  gap: 12px;
  margin-bottom: 20px;
  border-radius: 12px;
  overflow: hidden;
}

.image-single {
  grid-template-columns: 1fr;
}

.image-grid {
  grid-template-columns: repeat(2, 1fr);
}

.image-wrapper {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 16/9;
}

.post-image {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  transition: transform 0.3s ease;
}

.post-image:hover {
  transform: scale(1.05);
}

.more-images {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 600;
}

/* Ê†áÁ≠æÊ†∑Âºè */
.post-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
}

.post-tag {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 16px;
  padding: 4px 12px;
  font-size: 12px;
  transition: all 0.3s ease;
  cursor: pointer;
}

.post-tag:hover {
  background: #667eea;
  color: white;
  transform: translateY(-2px);
}

/* Êìç‰ΩúÊåâÈíÆÂå∫Âüü */
.post-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid #f0f0f0;
}

.actions-left {
  display: flex;
  gap: 24px;
}

.action-item {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  color: #6c757d;
  transition: all 0.3s ease;
  padding: 8px 12px;
  border-radius: 20px;
  user-select: none;
}

.action-item:hover {
  color: #667eea;
  background: rgba(102, 126, 234, 0.1);
  transform: translateY(-2px);
}

.action-item.active {
  color: #ff6b6b;
  background: rgba(255, 107, 107, 0.1);
}

.action-icon {
  display: flex;
  align-items: center;
  justify-content: center;
}

.action-icon svg {
  width: 18px;
  height: 18px;
  transition: transform 0.3s ease;
}

.action-item:hover .action-icon svg {
  transform: scale(1.2);
}

.action-text {
  font-weight: 500;
  font-size: 14px;
}

.share-action {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  color: #6c757d;
  transition: all 0.3s ease;
  cursor: pointer;
}

.share-action:hover {
  background: rgba(102, 126, 234, 0.1);
  color: #667eea;
  transform: scale(1.1);
}

.share-action svg {
  width: 18px;
  height: 18px;
}

/* Âä†ËΩΩÁä∂ÊÄÅ */
.loading-container {
  background: white;
  border-radius: 20px;
  padding: 24px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
}

.loading-skeleton {
  padding: 16px;
}

/* ÈîôËØØÁä∂ÊÄÅ */
.error-container {
  display: flex;
  justify-content: center;
  margin: 40px 0;
}

.error-card {
  background: white;
  border-radius: 16px;
  padding: 40px;
  text-align: center;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
  max-width: 400px;
  width: 100%;
}

.error-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.error-message {
  color: #6c757d;
  margin-bottom: 24px;
  line-height: 1.6;
}

/* Á©∫Áä∂ÊÄÅ */
.empty-state {
  display: flex;
  justify-content: center;
  margin: 40px 0;
}

.empty-card {
  background: white;
  border-radius: 20px;
  padding: 60px 40px;
  text-align: center;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
  max-width: 400px;
  width: 100%;
}

.empty-icon {
  font-size: 64px;
  margin-bottom: 16px;
}

.empty-title {
  font-size: 20px;
  font-weight: 600;
  color: #2c3e50;
  margin-bottom: 8px;
}

.empty-subtitle {
  color: #6c757d;
  line-height: 1.6;
}

/* Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ */
.load-more {
  text-align: center;
  margin-top: 32px;
}

.load-more-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border: none;
  border-radius: 25px;
  padding: 12px 32px;
  color: white;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.3s ease;
}

.load-more-btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
}

.load-more-btn svg {
  width: 16px;
  height: 16px;
}

/* ÂØπËØùÊ°ÜÊ†∑Âºè */
.modern-dialog :deep(.el-dialog) {
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
}

.modern-dialog :deep(.el-dialog__header) {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  padding: 20px 24px;
  margin: 0;
}

.modern-dialog :deep(.el-dialog__title) {
  font-weight: 600;
  font-size: 18px;
}

.modern-dialog :deep(.el-dialog__body) {
  padding: 0;
}

/* ËØÑËÆ∫ÂØπËØùÊ°ÜÊ†∑Âºè */
.comments-dialog :deep(.el-dialog) {
  max-width: 800px;
}

.comment-post-title {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 24px;
  padding: 20px 24px;
  background: #f8f9fa;
  color: #2c3e50;
  border-bottom: 1px solid #e9ecef;
}

.comment-input-container {
  margin: 24px;
  background: #f8f9fa;
  padding: 20px;
  border-radius: 16px;
  border: 2px solid #e9ecef;
  transition: all 0.3s ease;
}

.comment-input-container:focus-within {
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.comment-input-header {
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  gap: 12px;
}

.comment-avatar {
  border: 2px solid #667eea;
}

.comment-username {
  font-weight: 600;
  color: #2c3e50;
}

.comment-textarea :deep(.el-textarea__inner) {
  border: none;
  background: white;
  border-radius: 12px;
  padding: 16px;
  font-size: 15px;
  line-height: 1.6;
  resize: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.comment-textarea :deep(.el-textarea__inner):focus {
  box-shadow: 0 4px 16px rgba(102, 126, 234, 0.2);
}

.comment-input-actions {
  display: flex;
  justify-content: flex-end;
  margin-top: 12px;
}

.submit-comment-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border: none;
  border-radius: 20px;
  padding: 10px 24px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.submit-comment-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.comment-list-header {
  font-size: 16px;
  font-weight: 600;
  margin: 0 24px 20px;
  color: #2c3e50;
  padding-bottom: 12px;
  border-bottom: 2px solid #f0f0f0;
}

.comment-list {
  max-height: 500px;
  overflow-y: auto;
  padding: 0 24px 24px;
}

.comments-container {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.comment-item {
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid #f0f0f0;
  transition: all 0.3s ease;
}

.comment-item:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.comment-item-header {
  margin-bottom: 12px;
}

.comment-user-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.comment-user-avatar {
  border: 2px solid #f8f9fa;
}

.comment-user-details {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.comment-username {
  font-weight: 600;
  color: #2c3e50;
  font-size: 14px;
}

.comment-time {
  font-size: 12px;
  color: #6c757d;
}

.comment-item-content {
  font-size: 15px;
  line-height: 1.6;
  margin-bottom: 16px;
  color: #495057;
}

.comment-item-actions {
  display: flex;
  gap: 16px;
}

.comment-action-item {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  color: #6c757d;
  transition: all 0.3s ease;
  padding: 6px 12px;
  border-radius: 12px;
  font-size: 13px;
  font-weight: 500;
}

.comment-action-item:hover {
  color: #667eea;
  background: rgba(102, 126, 234, 0.1);
}

.comment-action-item.active {
  color: #ff6b6b;
  background: rgba(255, 107, 107, 0.1);
}

.comment-action-item svg {
  width: 16px;
  height: 16px;
}

.empty-comments {
  text-align: center;
  padding: 60px 20px;
}

.empty-comment-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.empty-comment-text {
  color: #6c757d;
  font-size: 16px;
  line-height: 1.6;
}

.reply-target {
  background: #f0f7ff;
  border-left: 3px solid #409eff;
  padding: 8px 12px;
  margin-bottom: 10px;
  border-radius: 4px;
  font-size: 13px;
  display: flex;
  align-items: center;
}

.reply-target-name {
  font-weight: 600;
  color: #409eff;
  margin: 0 5px;
}

/* ÂõûÂ§ç‰ø°ÊÅØ */
.reply-to-info {
  background: #f5f7fa;
  padding: 4px 8px;
  border-radius: 4px;
  margin-top: 8px;
  font-size: 13px;
  display: inline-block;
}

.reply-to-name {
  font-weight: 600;
  color: #409eff;
}

/* ÂõûÂ§çÂÆπÂô® */
.replies-container {
  margin-top: 15px;
  padding-left: 40px;
  border-left: 2px solid #f0f2f5;
}

.reply-item {
  background: #f8f9fa;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
}

.reply-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.reply-avatar {
  margin-right: 10px;
}

.reply-user {
  display: flex;
  flex-direction: column;
}

.reply-username {
  font-weight: 600;
  font-size: 13px;
}

.reply-time {
  font-size: 11px;
  color: #909399;
}

.reply-content {
  font-size: 14px;
  line-height: 1.5;
}

.reply-to {
  color: #409eff;
  font-weight: 500;
  margin-right: 5px;
}

.reply-actions {
  display: flex;
  margin-top: 8px;
  font-size: 12px;
}

.reply-action {
  display: flex;
  align-items: center;
  margin-right: 15px;
  color: #606266;
  cursor: pointer;
  transition: color 0.2s;
}

.reply-action:hover {
  color: #409eff;
}

.reply-action.active {
  color: #ff6b6b;
}

.reply-action svg {
  margin-right: 4px;
}

/* Êî∂ËóèÂ§πÊ®°ÊÄÅÊ°ÜÊ†∑Âºè */
.favorites-modal :deep(.el-dialog) {
  max-width: 500px;
}

.favorites-content {
  max-height: 400px;
  overflow-y: auto;
}

.create-folder-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: all 0.3s ease;
}

.create-folder-item:hover {
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
}

.create-folder-item .folder-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.create-icon {
  font-size: 20px;
  color: #667eea;
}

.folder-name {
  font-size: 15px;
  font-weight: 600;
  color: #667eea;
}

.favorites-list {
  padding: 0;
}

.folder-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid #f0f0f0;
  transition: all 0.3s ease;
}

.folder-item:hover {
  background: #f8f9fa;
}

.folder-item.recently-used {
  background: linear-gradient(135deg, #fff7e6, #fef3e2);
  border-left: 4px solid #faad14;
}

.folder-info {
  flex: 1;
}

.folder-main .folder-name {
  font-size: 15px;
  font-weight: 600;
  color: #2c3e50;
  margin-bottom: 6px;
}

.folder-meta {
  display: flex;
  align-items: center;
  font-size: 13px;
  color: #6c757d;
  gap: 6px;
}

.separator {
  color: #dee2e6;
}

.recent-tag {
  margin-left: 8px;
}

.item-count, .privacy-status {
  color: #6c757d;
}

.collect-btn {
  border-radius: 16px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.collect-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* ÂàõÂª∫Êî∂ËóèÂ§πÂØπËØùÊ°Ü */
.create-dialog :deep(.el-dialog) {
  max-width: 450px;
}

.create-form {
  padding: 20px 0;
}

.form-input :deep(.el-input__inner),
.form-textarea :deep(.el-textarea__inner) {
  border-radius: 12px;
  border: 2px solid #e9ecef;
  padding: 12px 16px;
  transition: all 0.3s ease;
}

.form-input :deep(.el-input__inner):focus,
.form-textarea :deep(.el-textarea__inner):focus {
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.privacy-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.privacy-option {
  background: #f8f9fa;
  border: 2px solid #e9ecef;
  border-radius: 12px;
  padding: 16px;
  transition: all 0.3s ease;
  margin: 0;
}

.privacy-option:hover {
  border-color: #667eea;
  background: rgba(102, 126, 234, 0.05);
}

.privacy-option.is-checked {
  border-color: #667eea;
  background: rgba(102, 126, 234, 0.1);
}

.privacy-content {
  display: flex;
  align-items: center;
  gap: 12px;
  width: 100%;
}

.privacy-icon {
  font-size: 20px;
}

.privacy-text {
  display: flex;
  flex-direction: row;
  gap: 12px;
}

.privacy-title {
  font-weight: 600;
  color: #2c3e50;
}

.privacy-desc {
  font-size: 13px;
  color: #6c757d;
}

.dialog-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px 0 0;
}

.cancel-btn {
  border-radius: 20px;
  padding: 10px 24px;
  border: 2px solid #e9ecef;
  transition: all 0.3s ease;
}

.cancel-btn:hover {
  border-color: #6c757d;
  color: #6c757d;
}

.create-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border: none;
  border-radius: 20px;
  padding: 10px 24px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.create-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

/* ÂìçÂ∫îÂºèËÆæËÆ° */
@media (max-width: 768px) {
  .community-container {
    padding: 16px;
  }

  .modern-card {
    padding: 20px;
    border-radius: 16px;
  }

  .post-images.image-grid {
    grid-template-columns: 1fr;
  }

  .actions-left {
    gap: 16px;
  }

  .action-item {
    padding: 6px 8px;
  }

  .action-text {
    font-size: 13px;
  }

  .tags-container {
    gap: 8px;
  }

  .modern-dialog :deep(.el-dialog) {
    width: 95% !important;
    margin: 5vh auto;
  }

  .comment-input-container,
  .comment-list {
    margin: 16px;
    padding: 16px;
  }

  .folder-item,
  .create-folder-item {
    padding: 16px 20px;
  }
}

@media (max-width: 576px) {
  .user-info {
    gap: 8px;
  }

  .user-avatar {
    width: 36px !important;
    height: 36px !important;
  }

  .post-title {
    font-size: 18px;
  }

  .post-content {
    font-size: 14px;
  }

  .post-actions {
    flex-direction: column;
    gap: 12px;
  }

  .actions-left {
    justify-content: space-around;
    width: 100%;
  }

  .tag-section {
    gap: 12px;
  }

  .tags-container {
    gap: 6px;
  }

  .modern-tag {
    padding: 6px 12px;
    font-size: 12px;
  }
}

/* ÊªöÂä®Êù°Ê†∑Âºè */
.comment-list::-webkit-scrollbar,
.favorites-content::-webkit-scrollbar {
  width: 6px;
}

.comment-list::-webkit-scrollbar-track,
.favorites-content::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.comment-list::-webkit-scrollbar-thumb,
.favorites-content::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

.comment-list::-webkit-scrollbar-thumb:hover,
.favorites-content::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Âä®ÁîªÊïàÊûú */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.modern-card {
  animation: fadeInUp 0.6s ease-out;
}

.modern-card:nth-child(2) { animation-delay: 0.1s; }
.modern-card:nth-child(3) { animation-delay: 0.2s; }
.modern-card:nth-child(4) { animation-delay: 0.3s; }
.modern-card:nth-child(5) { animation-delay: 0.4s; }
</style>